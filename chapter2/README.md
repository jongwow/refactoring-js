# 2. 리팩터링 원칙

## 2.1 리팩터링 정의

- **리팩터링**[명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

- **리팩터링**[동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

- 코드 베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성, _restructuring_' 이라 표현하고, 리팩터링은 재구성 중 특수한 한 형태.

- 리팩터링의 겉보기 동작*observable behavior*은 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 것.

- 리팩터링은 성능 최적화와 비슷하다. 코드는 변경하는데 기능은 유지하는 것은 같다. 하지만 목적이 다르다. 리팩터링의 목적은 코드를 이해하고 수정하고 쉽게 만드는 것. 성능은 좋아질수도, 나빠질수도 있다.

## 2.2 두 개의 모자

- 소프트웨어 개발할 때 **기능 추가** 또는 **리팩터링** 이냐를 구분해 작업할 것. 켄트백은 이것을 두 개의 모자에 비유.
- **기능 추가**를 할 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하지만 한다.
- **리팩터링**을 할 때는 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념하다.

## 2.3 리팩터링하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.

## 2.4 언제 리팩터링해야 할까?

### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼따는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링(Preparatory Refactoring): 기능을 쉽게 추가하게 만들기

- 리팩터링을 하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

### 이해를 위한 리팩터링(Comprehension Refactoring): 코드를 이해하기 쉽게 만들기

- 코드 분석을 할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

### 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)

- 일을 비효울적으로 처리하는 부분을 고치는 것. 원래 하려던 작업이 아니기 때문에 간단한건 그자리에서 수정하고, 시간이 오래 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

- 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 기회가 될 때만 진행.
- 마틴파울러는 리팩터링 일정을 따로 잡아두지 않고 프로그래밍 과정에 자연스럽게 녹인다.
  > 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 한다. - 마틴 파울러

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.

### 오래 걸리는 리팩터링

- 리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간이다.
- 팀 전체가 매달리는 리팩터링은 회의적. 누구든 관련된 코드를 작업할 때 조금씩 개선해야할 것.

### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰는 개발 팀 전체에 지식 전파에 좋다. 시니어가 주니어에게 노하우를 알려줄 수 도, 깔끔한 코드를 작성하는데도, 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.
- 리팩터링은 다른 이의 코드를 리뷰하는데도 도움. 코드 리뷰 결과를 더 구체적으로 도출하는 데에 도움.

### 관리자에게는 뭐라고 말해야할까?

- 관리자가 기술에 정통하면 리팩터링의 필요성을 쉽게 설득 가능하다.
- 그렇지 않다면, "리팩터링한다고 말하지 말라"

### 리팩터링하지 말아야 할 때

지금까지의 이야기가 무조건 리팩터링을 권장한다고 들릴 수 있지만 리팩터링하면 안되는 상황도 있다.

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 안흔ㄴ다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드', '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 **경제적인 이유**로 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

### 코드 소유권

내 코드가 아닌 다른 팀의 코드나 연동되는 코드라면 리팩터링에 방해가 된다. 그래서 코드 소유권은 작은 단위보단 팀에 맡기고 그 팀내에선 자유롭게 관리하는 것을 선호한다.

### 브랜치

흔히 보는 팀 단위 작업 방식은 VCS로 팀원마다 브랜치를 맡아 작업하다가 마스터 브랜치에 통합하는 것. 기능 추가마다 버전 명확히 분리 + 기능에 문제 생기면 이전 상태 되돌리기 편함.

하지만 단점: 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터브랜치에 통합하기 어려워짐. 그래서 마스터를 개인 브랜치에 수시로 rebase, merge함.

나*마틴파울러*는 머지와 통합을 명확히 구분.

- 마스터를 브랜치로 **머지**하는 작업은 단방향. 브랜치만 바뀌고 마스터는 그대로.
- 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향이 **통합**. 개인 브랜치, 마스터 브랜치 모두 변경.

머지가 복잡해지는 문제는 기능별 브랜치가 독립 개발되는 기간이 길어질수록 기하급수적으로 늘어남.
그래서 2~3일 단위로 짧게 관리해야 한다고 주장. CI(Continuous Integration), 또는 트렁크 기반 개발(TBD)라 함. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 그러려면 마스터를 건강하게 유지하고 거대한 기능을 잘게 쫒개고 각 기능을 끌 수 있ㄴ느 기능 토글을 적용해 완료되지 않은 기능이 시스템을 망치지 않도록 해야함.

CI는 Refactoring과 궁합 GOOD. 그래서 XP(eXtreme Programming) 등장.

### 테스팅

- 겉보기 동작은 똑같이 유지 -> 오류를 빨리 잡아내야함 -> 테스트 스위트(Test Suite)가 필요 -> self-testing code가 필요하다.
- 자가 테스크 코드는 CI와도 밀접하게 연관.

### 레거시 코드

- 레거시 시스템을 파악할 때 리팩터링은 굉장히 도움된다.
- 테스트가 없는 시스템은 명료하게 리팩터링하기 힘들다. 그럴 땐 "레거시 코드 활용 전략"에 나온 지침을 따르는 것이 좋다. **프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다**

### 데이터베이스

- **진화형 데이터베이스 설계**와 **데이터베이스 리팩터링**기법은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합한다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 기존엔 SW설계와 아키텍처는 바꾸기 힘들기 때문에 시작 전에 어느정도, 심지어 거의 완료해야 한다는 것이 정설
- 하지만 리팩터링의 등장으로 현재 필요한 요구사항만을 해결하는 SW를 구축
- 이런 설계를 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(you aren't going to need it)이라 부른다.
- 선제적인 설계가 중요하지 않다는 것이 아니다. 다만 그 균형점이 크게 달라졌고 문제를 깊이 이해하고 처리하는 것이 낫다고 생각한다는 것이다. 이런 경향으 진화형 아키텍처(evolutionary architecture)원칙이 발전하는 계기가 되었다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- XP의 두드러진 특징은 **지속적 통합**, **자가 테스트 코드**, **리팩터링** 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점.
- 자가 테스트 코드 + 리팩터링 = 테스트 주도 개발 (Test-Driven Development)

## 2.8 리팩터링과 성능
- "직관적인 설계 vs 성능"은 중요한 주제.
- 첫번째 방법: 시간 예산 분배 방식. 하드 리얼타임 시스템에서 사용
- 두번째 방법: 끊임없는 관심을 기울이는 것
- 세번째 방법: 의도적으로 성능 최적화 전까진 코드를 쉽게 만들고, 성능 최적화단계에서 프로파일러 -> 개선 -> 프로파일링 -> 개선을 반복한다.

## 2.9 리팩터링의 유래
## 2.10 리팩터링 자동화
- 인텔리제이나 이클립스와 같은 IDEA에서 자동 리팩터링 기능을 제공
- 자동 리팩터링은 코드를 텍스트 상태가 아닌 구문 트리(syntax tree)로 분석
- 요즘엔 언어 서버(language server)라는 구문 트리를 구성해 텍스트 에디어테 API 형태로 제공하는 SW가 뜨고 있다.