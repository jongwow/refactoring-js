# 2. 리팩터링 원칙

## 2.1 리팩터링 정의

- **리팩터링**[명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

- **리팩터링**[동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

- 코드 베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성, _restructuring_' 이라 표현하고, 리팩터링은 재구성 중 특수한 한 형태.

- 리팩터링의 겉보기 동작*observable behavior*은 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 것.

- 리팩터링은 성능 최적화와 비슷하다. 코드는 변경하는데 기능은 유지하는 것은 같다. 하지만 목적이 다르다. 리팩터링의 목적은 코드를 이해하고 수정하고 쉽게 만드는 것. 성능은 좋아질수도, 나빠질수도 있다.

## 2.2 두 개의 모자

- 소프트웨어 개발할 때 **기능 추가** 또는 **리팩터링** 이냐를 구분해 작업할 것. 켄트백은 이것을 두 개의 모자에 비유.
- **기능 추가**를 할 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하지만 한다.
- **리팩터링**을 할 때는 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념하다.

## 2.3 리팩터링하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.

## 2.4 언제 리팩터링해야 할까?

### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼따는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링(Preparatory Refactoring): 기능을 쉽게 추가하게 만들기

- 리팩터링을 하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

### 이해를 위한 리팩터링(Comprehension Refactoring): 코드를 이해하기 쉽게 만들기

- 코드 분석을 할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

### 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)

- 일을 비효울적으로 처리하는 부분을 고치는 것. 원래 하려던 작업이 아니기 때문에 간단한건 그자리에서 수정하고, 시간이 오래 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

- 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 기회가 될 때만 진행.
- 마틴파울러는 리팩터링 일정을 따로 잡아두지 않고 프로그래밍 과정에 자연스럽게 녹인다.
  > 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 한다. - 마틴 파울러

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.

### 오래 걸리는 리팩터링

- 리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간이다.
- 팀 전체가 매달리는 리팩터링은 회의적. 누구든 관련된 코드를 작업할 때 조금씩 개선해야할 것.

### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰는 개발 팀 전체에 지식 전파에 좋다. 시니어가 주니어에게 노하우를 알려줄 수 도, 깔끔한 코드를 작성하는데도, 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.
- 리팩터링은 다른 이의 코드를 리뷰하는데도 도움. 코드 리뷰 결과를 더 구체적으로 도출하는 데에 도움.

### 관리자에게는 뭐라고 말해야할까?

- 관리자가 기술에 정통하면 리팩터링의 필요성을 쉽게 설득 가능하다.
- 그렇지 않다면, "리팩터링한다고 말하지 말라"

### 리팩터링하지 말아야 할 때

지금까지의 이야기가 무조건 리팩터링을 권장한다고 들릴 수 있지만 리팩터링하면 안되는 상황도 있다.

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 안흔ㄴ다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드', '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 **경제적인 이유**로 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

### 코드 소유권

내 코드가 아닌 다른 팀의 코드나 연동되는 코드라면 리팩터링에 방해가 된다. 그래서 코드 소유권은 작은 단위보단 팀에 맡기고 그 팀내에선 자유롭게 관리하는 것을 선호한다.

### 브랜치

흔히 보는 팀 단위 작업 방식은 VCS로 팀원마다 브랜치를 맡아 작업하다가 마스터 브랜치에 통합하는 것. 기능 추가마다 버전 명확히 분리 + 기능에 문제 생기면 이전 상태 되돌리기 편함.

하지만 단점: 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터브랜치에 통합하기 어려워짐. 그래서 마스터를 개인 브랜치에 수시로 rebase, merge함.

나*마틴파울러*는 머지와 통합을 명확히 구분.

- 마스터를 브랜치로 **머지**하는 작업은 단방향. 브랜치만 바뀌고 마스터는 그대로.
- 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향이 **통합**. 개인 브랜치, 마스터 브랜치 모두 변경.

머지가 복잡해지는 문제는 기능별 브랜치가 독립 개발되는 기간이 길어질수록 기하급수적으로 늘어남.
그래서 2~3일 단위로 짧게 관리해야 한다고 주장. CI(Continuous Integration), 또는 트렁크 기반 개발(TBD)라 함. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 그러려면 마스터를 건강하게 유지하고 거대한 기능을 잘게 쫒개고 각 기능을 끌 수 있ㄴ느 기능 토글을 적용해 완료되지 않은 기능이 시스템을 망치지 않도록 해야함.

CI는 Refactoring과 궁합 GOOD. 그래서 XP(eXtreme Programming) 등장.

### 테스팅

- 겉보기 동작은 똑같이 유지 -> 오류를 빨리 잡아내야함 -> 테스트 스위트(Test Suite)가 필요 -> self-testing code가 필요하다.
- 자가 테스크 코드는 CI와도 밀접하게 연관. 

### 레거시 코드